name: CI/CD Pipeline

on:
  push:
    tags:
      - 'v[0-9]+.[0-9]+.[0-9]+'

permissions:
  contents: write
  packages: write

env:
  DOCKER_IMAGE_NAME: ${{ secrets.DOCKERHUB_USERNAME }}/currencyarchiveapi

jobs:
  extract-version:
    name: Extract Version
    runs-on: ubuntu-latest
    timeout-minutes: 5
    outputs:
      tag_name: ${{ steps.version.outputs.tag_name }}
      version: ${{ steps.version.outputs.version }}
      assembly_version: ${{ steps.version.outputs.assembly_version }}
      commit_count: ${{ steps.version.outputs.commit_count }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Extract and validate version from tag
        id: version
        run: |
          # Extract tag name (e.g., v1.0.0)
          TAG_NAME="${GITHUB_REF#refs/tags/}"
          echo "Tag name: ${TAG_NAME}"
          
          # Remove 'v' prefix to get version (e.g., 1.0.0)
          VERSION="${TAG_NAME#v}"
          
          # Validate version format (must be X.Y.Z)
          if ! [[ "$VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "Error: Invalid version format. Expected X.Y.Z, got: ${VERSION}"
            exit 1
          fi
          
          # Get commit count for 4-digit assembly version
          COMMIT_COUNT=$(git rev-list --count HEAD)
          
          # Create 4-digit assembly version: Major.Minor.Patch.CommitCount
          ASSEMBLY_VERSION="${VERSION}.${COMMIT_COUNT}"
          
          # Set outputs
          echo "tag_name=${TAG_NAME}" >> $GITHUB_OUTPUT
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "assembly_version=${ASSEMBLY_VERSION}" >> $GITHUB_OUTPUT
          echo "commit_count=${COMMIT_COUNT}" >> $GITHUB_OUTPUT
          
          # Display results
          echo "Tag: ${TAG_NAME}"
          echo "Version (3-digit): ${VERSION}"
          echo "Assembly Version (4-digit): ${ASSEMBLY_VERSION}"
          echo "Commit Count: ${COMMIT_COUNT}"

  build-and-push:
    name: Build and Push Docker Image
    runs-on: ubuntu-latest
    timeout-minutes: 30
    needs: extract-version
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}
      
      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./src/Dockerfile
          push: true
          tags: |
            ${{ env.DOCKER_IMAGE_NAME }}:${{ needs.extract-version.outputs.version }}
            ${{ env.DOCKER_IMAGE_NAME }}:latest
          cache-from: type=registry,ref=${{ env.DOCKER_IMAGE_NAME }}:buildcache
          cache-to: type=registry,ref=${{ env.DOCKER_IMAGE_NAME }}:buildcache,mode=max
          build-args: |
            BUILD_CONFIGURATION=Release
      
      - name: Docker image built successfully
        run: |
          echo "Docker image built and pushed successfully"
          echo "Image: ${{ env.DOCKER_IMAGE_NAME }}"
          echo "Version: ${{ needs.extract-version.outputs.version }}"

  update-version:
    name: Update Project Version
    runs-on: ubuntu-latest
    timeout-minutes: 5
    needs: [extract-version, build-and-push]
    if: success()
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ github.token }}
      
      - name: Configure Git
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
      
      - name: Update Directory.Build.props
        id: update
        run: |
          VERSION="${{ needs.extract-version.outputs.version }}"
          ASSEMBLY_VERSION="${{ needs.extract-version.outputs.assembly_version }}"
          
          echo "Updating Directory.Build.props"
          echo "VersionPrefix: ${VERSION}"
          echo "AssemblyVersion: ${ASSEMBLY_VERSION}"
          echo "FileVersion: ${ASSEMBLY_VERSION}"
          
          # Update VersionPrefix (3-digit version from tag)
          sed -i "s|<VersionPrefix>.*</VersionPrefix>|<VersionPrefix>${VERSION}</VersionPrefix>|g" Directory.Build.props
          
          # Update AssemblyVersion (4-digit version with commit count)
          sed -i "s|<AssemblyVersion>.*</AssemblyVersion>|<AssemblyVersion>${ASSEMBLY_VERSION}</AssemblyVersion>|g" Directory.Build.props
          
          # Update FileVersion (4-digit version with commit count)
          sed -i "s|<FileVersion>.*</FileVersion>|<FileVersion>${ASSEMBLY_VERSION}</FileVersion>|g" Directory.Build.props
          
          echo "Updated Directory.Build.props:"
          grep -E "(VersionPrefix|AssemblyVersion|FileVersion)" Directory.Build.props
          
          # Check if there are changes
          if git diff --quiet Directory.Build.props; then
            echo "No version changes detected"
            echo "has_changes=false" >> $GITHUB_OUTPUT
          else
            echo "Version changes detected"
            echo "has_changes=true" >> $GITHUB_OUTPUT
          fi
      
      - name: Create Pull Request
        if: steps.update.outputs.has_changes == 'true'
        id: cpr
        uses: peter-evans/create-pull-request@v6
        with:
          token: ${{ github.token }}
          commit-message: 'chore: update version to ${{ needs.extract-version.outputs.version }} (assembly: ${{ needs.extract-version.outputs.assembly_version }}) [skip ci]'
          branch: version-update-${{ needs.extract-version.outputs.version }}
          delete-branch: true
          title: 'Update version to ${{ needs.extract-version.outputs.version }}'
          body: |
            Automated version update for release ${{ needs.extract-version.outputs.tag_name }}
            
            - Version: ${{ needs.extract-version.outputs.version }}
            - Assembly Version: ${{ needs.extract-version.outputs.assembly_version }}
            - Commit Count: ${{ needs.extract-version.outputs.commit_count }}
            
            Auto-generated by GitHub Actions
          labels: automated
      
      - name: Enable auto-merge for PR
        if: steps.cpr.outputs.pull-request-number != ''
        env:
          GH_TOKEN: ${{ github.token }}
          PR_NUMBER: ${{ steps.cpr.outputs.pull-request-number }}
        run: |
          gh pr merge --auto --rebase --delete-branch "$PR_NUMBER"

  create-release:
    name: Create GitHub Release
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: [extract-version, build-and-push, update-version]
    if: success()
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ github.token }}
      
      - name: Generate release notes
        id: release_notes
        run: |
          CURRENT_TAG="${{ needs.extract-version.outputs.tag_name }}"
          
          # Find previous tag
          PREVIOUS_TAG=$(git tag --sort=-version:refname | grep -v "^${CURRENT_TAG}$" | head -n1 2>/dev/null || echo "")
          
          if [ -z "$PREVIOUS_TAG" ]; then
            # No previous tag, use first commit
            PREVIOUS_TAG=$(git rev-list --max-parents=0 HEAD)
            echo "Generating release notes from initial commit to ${CURRENT_TAG}"
          else
            echo "Generating release notes from ${PREVIOUS_TAG} to ${CURRENT_TAG}"
          fi
          
          # Initialize changelog
          CHANGELOG="## What's Changed"$'\n\n'
          
          # Get commits grouped by conventional commit type
          FEATURES=$(git log ${PREVIOUS_TAG}..HEAD --pretty=format:"- %s (%h)" --grep="^feat" --grep="^feat:" --grep="^feat(" 2>/dev/null || echo "")
          FIXES=$(git log ${PREVIOUS_TAG}..HEAD --pretty=format:"- %s (%h)" --grep="^fix" --grep="^fix:" --grep="^fix(" 2>/dev/null || echo "")
          PERF=$(git log ${PREVIOUS_TAG}..HEAD --pretty=format:"- %s (%h)" --grep="^perf" --grep="^perf:" --grep="^perf(" 2>/dev/null || echo "")
          REFACTOR=$(git log ${PREVIOUS_TAG}..HEAD --pretty=format:"- %s (%h)" --grep="^refactor" --grep="^refactor:" --grep="^refactor(" 2>/dev/null || echo "")
          DOCS=$(git log ${PREVIOUS_TAG}..HEAD --pretty=format:"- %s (%h)" --grep="^docs" --grep="^docs:" --grep="^docs(" 2>/dev/null || echo "")
          
          # Build changelog sections
          if [ -n "$FEATURES" ]; then
            CHANGELOG="${CHANGELOG}### Features"$'\n'"${FEATURES}"$'\n\n'
          fi
          
          if [ -n "$FIXES" ]; then
            CHANGELOG="${CHANGELOG}### Bug Fixes"$'\n'"${FIXES}"$'\n\n'
          fi
          
          if [ -n "$PERF" ]; then
            CHANGELOG="${CHANGELOG}### Performance Improvements"$'\n'"${PERF}"$'\n\n'
          fi
          
          if [ -n "$REFACTOR" ]; then
            CHANGELOG="${CHANGELOG}### Code Refactoring"$'\n'"${REFACTOR}"$'\n\n'
          fi
          
          if [ -n "$DOCS" ]; then
            CHANGELOG="${CHANGELOG}### Documentation"$'\n'"${DOCS}"$'\n\n'
          fi
          
          # If no categorized commits found, show all commits
          if [ -z "$FEATURES" ] && [ -z "$FIXES" ] && [ -z "$PERF" ] && [ -z "$REFACTOR" ] && [ -z "$DOCS" ]; then
            ALL_COMMITS=$(git log ${PREVIOUS_TAG}..HEAD --pretty=format:"- %s (%h)" --no-merges 2>/dev/null || echo "")
            if [ -n "$ALL_COMMITS" ]; then
              CHANGELOG="${CHANGELOG}### All Changes"$'\n'"${ALL_COMMITS}"$'\n\n'
            else
              CHANGELOG="${CHANGELOG}- Initial release"$'\n\n'
            fi
          fi
          
          # Save to file
          echo "$CHANGELOG" > release_notes.md
          
          # Set output using heredoc
          {
            echo 'notes<<EOF'
            cat release_notes.md
            echo EOF
          } >> $GITHUB_OUTPUT
      
      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ needs.extract-version.outputs.tag_name }}
          name: Release ${{ needs.extract-version.outputs.tag_name }}
          body: |
            ## Release ${{ needs.extract-version.outputs.tag_name }}
            
            ${{ steps.release_notes.outputs.notes }}
            
            ---
            
            ### Build Information
            - **Version**: `${{ needs.extract-version.outputs.version }}`
            - **Assembly Version**: `${{ needs.extract-version.outputs.assembly_version }}`
            - **Docker Image**: `${{ env.DOCKER_IMAGE_NAME }}:${{ needs.extract-version.outputs.version }}`
            - **Commit**: `${{ github.sha }}`
            - **Commit Count**: `${{ needs.extract-version.outputs.commit_count }}`
            
            ### Docker Usage
            ```bash
            # Pull the image
            docker pull ${{ env.DOCKER_IMAGE_NAME }}:${{ needs.extract-version.outputs.version }}
            
            # Run the container
            docker run -p 8080:8080 ${{ env.DOCKER_IMAGE_NAME }}:${{ needs.extract-version.outputs.version }}
            ```
            
            ### Links
            - [Docker Hub](https://hub.docker.com/r/mzeshawn/currencyarchiveapi)
            - [Documentation](https://github.com/${{ github.repository }})
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GH_TOKEN }}
